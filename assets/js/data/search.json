[ { "title": "TypeScript Global Variables. feat! window", "url": "/posts/typescript-window-01/", "categories": "TypeScript, Kubeflow pipeline", "tags": "kubeflow pipeline, react, typescript, window", "date": "2022-06-08 23:20:00 +0900", "snippet": "개요 Kubeflow pipelines frontend 코드 살펴보다가 TypeScript 관련된 내용 정리.Why pipeline frontend side navigation 숨겨볼라고 코드 살펴보다가 확인. window[‘KFP_FLAGS’] -&gt; 이거 뭐???export const KFP_FLAGS = { DEPLOYMENT: // tslint:disable-next-line:no-string-literal window &amp;&amp; window['KFP_FLAGS'] ? // tslint:disable-next-line:no-string-literal window['KFP_FLAGS']['DEPLOYMENT'] === Deployments.KUBEFLOW ? Deployments.KUBEFLOW : // tslint:disable-next-line:no-string-literal window['KFP_FLAGS']['DEPLOYMENT'] === Deployments.MARKETPLACE ? Deployments.MARKETPLACE : DEPLOYMENT_DEFAULT : DEPLOYMENT_DEFAULT, HIDE_SIDENAV: window &amp;&amp; window['KFP_FLAGS'] ? window['KFP_FLAGS']['HIDE_SIDENAV'] : false,};HIDE_SIDENAV window.KFP_FLAGS.HIDE_SIDENAV 값으로 연결됨. 쓰임새 true이면 아래 sideNav를 그리지 않고 null을 return값 지정 window.KFP_FLAGS.HIDE_SIDENAV=true; window는 해당 page의 global 값을 저장하는 dom 객체로 사용됨. script로 위와 같이 값을 지정하면 아래와 같은 예시로 호출 window['KFP_FLAGS']['HIDE_SIDENAV'] 위의 예시에도 나와있다. pipeline frontend에선 index.html에서 값을 지정할 수 있다.&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; &lt;meta name=\"theme-color\" content=\"#000000\"&gt; &lt;link rel=\"shortcut icon\" href=\"%PUBLIC_URL%/static/favicon.ico\"&gt; &lt;title&gt;Kubeflow Pipelines&lt;/title&gt; &lt;script&gt; window.KFP_FLAGS={}; window.KFP_FLAGS.DEPLOYMENT='KUBEFLOW'; window.KFP_FLAGS.HIDE_SIDENAV=true; &lt;/script&gt; &lt;script id=\"kubeflow-client-placeholder\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;noscript&gt; You need to enable JavaScript to run this app. &lt;/noscript&gt; &lt;div id=\"root\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;마무리 window라고 달랑 지정되어 있고 값을 어디서 지정하는지 몰랐는데 알고보니 dom 객체…참고로 HIDE_SIDENAV를 true로 지정하면 아래와 같이 sidebar 사라짐." }, { "title": "npm ERR! getaddrinfo ENOTFOUND artifactory.twitter.biz (kubeflow pipeline frontend)", "url": "/posts/npm-error-01/", "categories": "npm, Kubeflow Pipeline", "tags": "kubeflow pipeline, react, node, error", "date": "2022-05-27 23:30:00 +0900", "snippet": "개요 Kubeflow pipeline frontend 한번 돌려보려다가 npm install에서 막힌 삽질기..가이드 잘못된 가이드 : https://github.com/kubeflow/pipelines/wiki/Frontend 내가 확인 했어야 하는 가이드 : https://github.com/kubeflow/pipelines/blob/master/frontend/README.mdError! 나를 좌절케 했던 에러… 아무리 찾아도 방법이 안나옴. 잘못된 가이드는 날 힘들게 한다. npm ERR! code ENOTFOUNDnpm ERR! syscall getaddrinfonpm ERR! errno ENOTFOUNDnpm ERR! network request to https://artifactory.twitter.biz/api/npm/js-virtual/util-extend/-/util-extend-1.0.3.tgz failed, reason: getaddrinfo ENOTFOUND artifactory.twitter.biznpm ERR! network This is a problem related to network connectivity.npm ERR! network In most cases you are behind a proxy or have bad network settings.npm ERR! networknpm ERR! network If you are behind a proxy, please make sure that thenpm ERR! network 'proxy' config is set properly. See: 'npm help config' 가이드 수행 비교 잘못된 가이드. npm install &lt;- 끝.. 여기서 안됨 npm start README (이 순서대로 하면 됨) node 14 설치 npm ci server directory에서 다시 npm ci mock-backend directory에서 또 npm ci frontend directory로 돌아가 npm start 그냥 단순하게 react니까 npm install 하면 끝이겠지..? 하고 위키에 나온대로 진행한게 잘못..마무리 혹시라도 위 Error 메세지를 만나게 되는 경우 도움이 되었기를 바라며… 상남자 특) node 싫어함." }, { "title": "Kafka Python Producer, Consumer", "url": "/posts/kafka-with-k8s-02/", "categories": "Kafka, Python", "tags": "Kafka, python, producer, consumer", "date": "2022-05-22 20:33:00 +0900", "snippet": "개요 지난시간에 설치한 kafka with k8s를 이용하여 python으로 producer, consumer 수행 테스트 Consumer 수행시켜 놓고 Producer 수행python 준비pip3 install kafka-pythonConsumer Topic명을 지정. Topic : test from kafka import KafkaConsumerconsumer = KafkaConsumer('test', bootstrap_servers='localhost:9092', enable_auto_commit=True, auto_offset_reset='latest')for message in consumer: print(message.value.decode('utf-8')) 수행python consumer.pyProducerimport timefrom json import dumpsfrom kafka import KafkaProducerproducer = KafkaProducer(acks=0, compression_type='gzip', bootstrap_servers=['localhost:9092'], value_serializer=lambda x: dumps(x).encode('utf-8'))start = time.time()for i in range(10): print(\"index \", i) data = {'str': 'result' + str(i)} producer.send('test', value=data) producer.flush()print(\"elapsed :\", time.time() - start) 수행python producer.py결과% python consumer.py{\"str\": \"result0\"}{\"str\": \"result1\"}{\"str\": \"result2\"}{\"str\": \"result3\"}{\"str\": \"result4\"}{\"str\": \"result5\"}{\"str\": \"result6\"}{\"str\": \"result7\"}{\"str\": \"result8\"}{\"str\": \"result9\"} consumer는 offset을 잘 지정해야한다.다음 목표 채팅이니까 우선 웹페이지… (아 싫어라)마무리 간단하게 kafka-python을 사용해봤는데 offset이나 여러가지 옵션을 이용해야 원활히 사용할 수 있을 것 같다." }, { "title": "Kafka with K8s", "url": "/posts/kafka-with-k8s-01/", "categories": "Kafka, Kubernetes", "tags": "Kafka, k8s, kubernetes", "date": "2022-05-21 23:30:00 +0900", "snippet": "개요 Kubernetes에 kafka를 설치하여 동작 테스트 minikube를 활용할 것임minikube &amp; Docker 설치 및 실행은 이전 포스트를 참고. 테스트 버전 minikube v1.25.2 kubernetes, kubectl v1.23.3 $ minikube start –nodes 옵션으로 node 갯수를 조절 가능. 하지만 내 맥북에선 사양탓인지 안되어서 하나의 node로 테스트Deploy Kafaka With Kubernetes 참고 사이트namespace 생성apiVersion: v1kind: Namespacemetadata: name: \"kafka\" labels: name: \"kafka\"Deploying Zookeeper port 는 2181apiVersion: v1kind: Servicemetadata: labels: app: zookeeper-service name: zookeeper-service namespace: kafkaspec: type: NodePort ports: - name: zookeeper-port port: 2181 nodePort: 30181 targetPort: 2181 selector: app: zookeeper---apiVersion: apps/v1kind: Deploymentmetadata: labels: app: zookeeper name: zookeeper namespace: kafkaspec: replicas: 1 selector: matchLabels: app: zookeeper template: metadata: labels: app: zookeeper spec: containers: - image: wurstmeister/zookeeper imagePullPolicy: IfNotPresent name: zookeeper ports: - containerPort: 2181 Cluster-IP 확인이 필요 NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEzookeeper-service NodePort 10.107.170.58 &lt;none&gt; 2181:30181/TCP 10h Deploying a Kafka Broker KAFKA_ZOOKEEPER_CONNECT에 위에서 확인한 Cluster-IP 10.107.170.58를 사용apiVersion: v1kind: Servicemetadata: labels: app: kafka-broker name: kafka-service namespace: kafkaspec: ports: - port: 9092 selector: app: kafka-broker---apiVersion: apps/v1kind: Deploymentmetadata: labels: app: kafka-broker name: kafka-broker namespace: kafkaspec: replicas: 1 selector: matchLabels: app: kafka-broker template: metadata: labels: app: kafka-broker spec: hostname: kafka-broker containers: - env: - name: KAFKA_BROKER_ID value: \"1\" - name: KAFKA_ZOOKEEPER_CONNECT value: 10.107.170.58:2181 - name: KAFKA_LISTENERS value: PLAINTEXT://:9092 - name: KAFKA_ADVERTISED_LISTENERS value: PLAINTEXT://kafka-broker:9092 image: wurstmeister/kafka imagePullPolicy: IfNotPresent name: kafka-broker ports: - containerPort: 9092hosts 수정 필요 헤당 예시는 kafka-broker로 host를 등록해야만 동작. 127.0.0.1 kafka-broker Testing 모든 파드가 떠있는지 확인한다.% kubectl get all -n kafkaNAME READY STATUS RESTARTS AGEpod/kafka-broker-5cbdf4c4fb-8cb4j 1/1 Running 1 (14m ago) 10hpod/zookeeper-55b668879d-qzgfs 1/1 Running 1 (14m ago) 10hNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEservice/kafka-service ClusterIP 10.110.57.129 &lt;none&gt; 9092/TCP 10hservice/zookeeper-service NodePort 10.107.170.58 &lt;none&gt; 2181:30181/TCP 10hNAME READY UP-TO-DATE AVAILABLE AGEdeployment.apps/kafka-broker 1/1 1 1 10hdeployment.apps/zookeeper 1/1 1 1 10hNAME DESIRED CURRENT READY AGEreplicaset.apps/kafka-broker-5cbdf4c4fb 1 1 1 10hreplicaset.apps/zookeeper-55b668879d 1 1 1 10h 서비스를 port-forward 하여 테스트 가능하도록 % kubectl port-forward svc/kafka-service 9092 -n kafka 테스트를 위해 kcat 설치 Mac OS는 brew install kcat kcat Command Test Producer % echo \"hello world\" | kcat -P -b 127.0.0.1:9092 -t test Consumer % kcat -C -b localhost:9092 -t testhello world% Reached end of topic test [0] at offset 1 다음 목표 python 예제로 producer, consumer 만들어 볼 예정마무리 Kafka에 대해 정확히 모르고 예시만 일단 따라해봄.. 그래서 hosts에 kafka-broker hostname 등록 안하고 싶었는데 아직 방법 확인 못함.공부가 필요하다.." }, { "title": "채팅 서비스 구조", "url": "/posts/chat-architecture-01/", "categories": "프로젝트", "tags": "chat, python, architecture", "date": "2022-05-15 22:00:00 +0900", "snippet": "개요 채팅 프로그램을 한번 설계해 보려고 한다. 그냥 파이썬 공부 쫌 해볼라고 개인 프로젝트로 간단한 채팅프로그램 해보는 것임.동기 &amp; 비동기 채팅이라 함은 동기가 될 수도 있고 비동기가 될 수도 있다. 하나의 채팅서버가 존재하고 여러 클라이언트가 접속된 경우 메세지는 채팅서버를 통해 바로바로 전달된다. (동기적) 채팅서버가 없다? 채팅 서버가 없어도 비동기 방식으로 메세지를 전달(게시)하고 구독중인 클라이언트에게 전달된다. (비동기적) 채팅서버가 채팅을 관리할 경우 빠른 메세지 전달이 가능하다. 채팅서버 없이 채팅을 게시하면 구독해 가는 방식이므로 채팅서버가 바로 전달해주는 것에 비해 메세지 전달이 느리다. 각자의 장단이 있다고 생각한다.사실 비동기는 채팅 시스템이라고 할 수 없을 것 같긴함.어쨋든 내가 생각하는 방식은 publisher &amp; Subscriber 방식.채팅서버를 관리하는 것보다는 좀 더 간단한 구조로 만들 수 있을 것 같다.Architecture 간단하게 설계해보면 아래와 같다.생각해볼 문제 일단 채팅 서비스는 카프카를 이용하여 만들까 생각중이다. 파이썬을 이용하여 Producer, Consumer를 구현 FastAPI를 통해 웹에서 테스트를 해볼건데… 메세지를 얼마나 보여줄 건지, 어떻게 각 producer, consumer를 구분할 것인지 이런 상세한 설계는 구현하면서.. 생각해보자.시스템 구성 카프카, python fastAPI, 웹은 일단 그냥 html, js, websocket?마무리 만들어보다가 중간중간 필요할 것 같은것들 추가해서 누더기 처럼 만들것임. 그래서 최종 Architecture는 변경될 수 있음" }, { "title": "블로그 진행 방향", "url": "/posts/smalltalk-01/", "categories": "잡담", "tags": "smalltalk", "date": "2022-05-12 20:50:00 +0900", "snippet": "블로그 작성에 대해…근래에 블로그 작성을 나름 열심히 하다가 이게 맞나… 싶은 기분이 들었다. 곰곰히 고민해 보니 쓸데 없는 자료만 올리고 있다는 생각이 들었다.찾아보면 다 나오는 것들? 그냥 일반적인 리서치, 이런 글들은 굳이 올릴 필요가 없는 것 같음…그래서 앞으로는 크게 중요하지 않은 리서치는 깃헙 위키에 찾아본 링크만 달아놓고 주제별로 분리해서 기록할 예정이다.그래서 앞으로 무엇을?원래는 자주 올리는 게 목표였지만,기존에 작성한 것들 중 한국투자증권 API 활용 글이나 실제로 업무중 겪은 이슈들을 작성한 글들이 있다.실제로 이러한 필요한 글만 올릴 예정이다. 이런 것들! 내가 실제로 실습한 내용. 책을 읽다가 한번 정리가 필요한 내용. (실습도 포함되는 내용 위주) 업무중 확인하거나 필요한 내용들. 앞으로 이러한 주제 위주로 올릴 예정임.목표개발자가 매일 매일 공부하는 것은 중요한 과제이자 목표라고 할 수 있다. 신기술은 언제나 새롭게 나오고 트렌드도 바뀌고 그것을 따라가기 위해 어쩔 수 없이 공부를 해야한다.하지만 업무 시간외에 남는 시간이… 특히 평일엔 그리 많지도 않고 사회생활도 해야하는데, 매일 공부를 한다는 것 자체가 힘든 상황이다.그래서 목표 방향은 적당히 시간 날 때 공부를 하자이다. 결국 거창한 목표는 아니고… 내게 허하는 시간내에서 알잘깔딱센으로 살아보고자 한다.목표를 세분화 해보면… 파이썬, 고랭으로 프로젝트 작성하기 깃헙에 지속적으로 관리하기 스프링 프레임워크 내실화 코드리뷰를 잘해보자! 딱히 기간은 없지만 2022년이 벌써 중반이지만 올 한해 힘내보려고 한다. (2023년까지는 지속적으로 하는게 목표!)마무리 블라인드나 여러 커뮤니티를 통해 개발자분들을 접해보면 참 열심히 하는 분들이 많다. 매일 매일 공부하는게 당연한거 아닌가? 라고 생각하는 분들도 많고,연차가 많이 쌓이긴 했지만 아직도 앞으로 20년은 남았으니, 꾸준히… 하고자 하는 마음 잃지 않는게 중요하다고 생각한다." }, { "title": "Java Bean Lifecycle", "url": "/posts/bean-lifecycle-01/", "categories": "Java, Bean", "tags": "java, bean, lifecycle", "date": "2022-05-08 21:00:00 +0900", "snippet": "개요스프링 빈 라이프사이클 관리를 통해 특점 시점에 통지를 받을 수 있음.빈 라이프사이클 출처 : (책) 전문가를 위한 스프링 5생성 통지 메커니즘 메서드 메커니즘 annotation 메커니즘 인터페이스 메커니즘 라이프사이클 통지를 받을 때 어떤 메커니즘을 사용할지는 애플리케이션 요구사항에 달려있습니다.메서드 메커니즘 init 메서드 생성 public class Singer {... private void init() { System.out.println(\"빈 초기화\"); ... }...} Context 구성 bean id=\"singerOne\" class=\"com.apress.prospring5.ch4.Singer\" init-method=\"init\" p:name=\"John Mayer\" p:age=\"39\" InitializingBean 인터페이스 구현 afterPropertiesSet() public class SingerWithInterface implements InitializingBean {... public void afterPropertiesSet() throws Exception { System.out.println(\"빈 초기화\"); ... }...} 일반적인 Context 구성 bean id=\"singerOne\" class=\"com.apress.prospring5.ch4.SingerWithInterface\" p:name=\"John Mayer\" p:age=\"39\" JSR-250 @PostConstruct 사용 @PostConstruct public class SingerWithJSR250 {... @PostConstruct private void init() throws Exception { System.out.println(\"빈 초기화\"); ... }...} 일반적인 Context 구성 context:annotation-configbean id=\"singerOne\" class=\"com.apress.prospring5.ch4.SingerWithInterface\" p:name=\"John Mayer\" p:age=\"39\" @Bean 초기화 메서드 선언 @Bean 지정시 initMethod를 지정할 수 있음 예시 public class SingerConfigDemo { @Configuratioin static class SingerConfig { @Lazy @Bean(initMethod = \"init\") Singer singleOne() { Singer singerOne = new Singer(); singerOne.setName(\"John Mayer\"); singerOne.setAge(39); return singerOne; } }} 초기화 메서드 해석 순서 이해하기 빈 생성을 위해 생성자를 호출 의존성을 주입 사전 초기화 담당 BeanPostProcessor 기반 빈들에게 확인 요청. @PostConstruct annotation은 CommonAnnotationBeanPostProcessor 빈이 적용된 메서드 호출. afterPropertiesSet, init-method 이전에 수행 InitializingBean의 afterPropertiesSet 실행 init-method 초기화 메서드 맨 마지막에 실행소멸 통지 일반적으로 소멸 콜백은 초기화 콜백과 쌍으로 사용.메서드 destroy-method=”destroy” Context 구성 bean id=\"destructiveBean\" class=\"com.apress.prospring5.ch4.DestructiveBean\" destroy-method=\"destroy\" init-method=\"afterPropertiesSet\" p:filePath=\"\" DisposableBean 인터페이스 구현public class DestructiveBeanWithInterface implements DisposableBean { ... @Override public void destroy() { System.out.println(\"빈을 소멸합니다.\"); ... } ...}JSR-250 @PreDestroy 사용public class DestructiveBeanWithJSR250 { @PreDestroy public void destroy() { System.out.println(\"빈을 소멸합니다.\"); }}@Bean 사용 소멸 메서드 정의public class DestructiveBeanConfigDemo { @Configuration static class DestructiveBeanConfig { @Lazy @Bean(destroyMethod = \"destroy\") DestructiveBean destructiveBean() { DestructiveBean destructiveBean = new DestructiveBean(); destructiveBean.setFilePath(\"\"); return destructiveBean; } }}해석 순서 초기화와 동일마무리 가끔 빈 초기화시 작업이 필요할 때 한번씩 찾아보면 좋을 듯 하다. 상황에 따라 골라 사용. 셧다운 후크는 패스하겠다." }, { "title": "Java HashMap", "url": "/posts/hash-01/", "categories": "Java, HashMap", "tags": "java, hasing, hashTable, hashMap", "date": "2022-05-04 21:00:00 +0900", "snippet": "개요Java의 대표 자료구조인 HashMap에 대해 간단하게 알아보자. HashMap이지만 핵심 메커니즘인 Hashing에 대해 조금 더 자세히 알아볼 것이다.HashMap (key, value) 쌍으로 값을 이루는 자료구조 자료구조내 값을 검색하는데 유리하다. hash function으로 생성된 hashCode 값을 가진 buckets의 index에 (Node)의 key, value가 지정됨. 그러므로 key값으로 index를 계산하여 한번에 접근이 가능.(O(1)) buckets은 아래 이미지를 보면 뭔지 이해감.HashMap Hierarchy 출처 : https://www.geeksforgeeks.org/java-util-hashmap-in-java-with-examples/ HashMap implements Serializable, Cloneable, Map&lt;K, V&gt; interfaces.HashMap, HashTable HashMap Non-thread-safe key에 null 허용 보조 해시 사용 (Collision 대비) HashTable Thread-safe key에 null 허용하지 않음 보조 해시 없음 Collision hash function에 의한 index 값이 중복 될 가능성이 있다. HashMap 에선 buckets 사이즈를 기본 사이즈에서 두배씩 늘리는 과정을 진행하는데 일정 사이즈를 늘리고 그래도 중복되면 보조 해시를 사용. (간략하게 정리하자면 그렇다…)기본적인 collision 해결법 Separate chaining 쉽게 말해 중복되면 해당 인덱스에 linkedlist로 꼬리를 달아서 저장. 저장 용량 불리 Java HashMap에서 사용하며 8 버전부터는 linkedlist 대신 tree를 사용. Open addressing 중복이면 다음 index에 추가. 해당 index에 값이 있으면 그 값도 한칸 밀어버림. 이미지 출처 : https://en.wikipedia.org/wiki/Hash_table 마무리 깊이 들어갈 필요는 없다고 생각한다. Hashing 알고리즘에 대해 어느정도 이해만 하고 넘어가면 필요할 때 찾아보면 더 쉽게 이해 가능할 듯." }, { "title": "Java JVM Memory", "url": "/posts/jvm-memory-01/", "categories": "Java, Jvm, Memory", "tags": "java, jvm, memory", "date": "2022-05-01 23:00:00 +0900", "snippet": "개요Java의 엔진인 JVM의 메모리 영역에 대해 한번 간단하게 알아보자.JVM간단히 설명하자면 Java 바이트 코드를 기계어로 번역해서 어느 시스템에서나 동작할 수 있도록 하는 엔진.쉽게 말하면 번역기.JVM 작업 유형 코드 로드 코드 확인 코드 실행 사용자에게 런타임 환경을 제공ClassLoader 클래스 파일을 로드하는데 사용되는 JVM의 하위 시스템입니다. 주로 세가지 작업을 담당 로딩(loading) 연결(linking) 초기화(initialization)메모리 영역 유형 출처 : https://www.geeksforgeeks.org/how-many-types-of-memory-areas-are-allocated-by-jvm/1. Class(Method) Area클래스 코드, 변수 코드, 메소드 코드, 생성자를 저장하는 메모리 영역. 런타임 상수 Pool, 필드 및 메서드 데이터, 메서드 코드와 같은 모든 클래스의 클래스 level 데이터를 저장2. Heap객체 생성 및 저장 메모리 영역. 클래스 인터페이스와 배열에 메모리를 할당. 객체에 메모리 할당.3. Stack스레드에 각각 Stack이 있습니다. 메소드에 대한 값을 반환, 동적 링크를 수행하는 동안 필요한 데이터 및 부분 결과를 저장.프레임을 저장하고 메서드를 호출할 때마다 새 프레임이 생성. 메서드 호출이 완료되면 프레임이 소멸.4. Program Counter Registernon-native 메소드는 사용 가능한 JVM 명령어의 주소를 저장하는 PC를 가지고 있는 반면, native 메소드에서는 프로그램 카운터의 값이 정의되지 않습니다. PC 레지스터는 특정 플랫폼에 반환 주소 또는 기본 포인터를 저장할 수 있습니다.5. Native Method StackC 스택이라고도 함. Java 언어로 작성되지 않습니다. 스레드가 생성될 때 각 스레드에 할당되며 고정되거나 동적일 수 있습니다.마무리 www.geeksforgeeks.org 여기서 잘 보고 가져왔습니다. 고맙습니다." }, { "title": "Java Primitive Type, Reference Type", "url": "/posts/data-type-01/", "categories": "Java, Data Type", "tags": "java, data type, primitive, reference", "date": "2022-04-28 22:40:00 +0900", "snippet": "개요Java의 대표 타입 두가지 Primitive Type, Reference Type에 대해 간단하게 아.라.보.자.Primitive Type 종류 : byte, short, int, long, float, double, boolean and char JVM Stack 영역에 저장. null 값을 가지지 않으며, 실제 데이터 값이 저장.Type Size Data Type Size Description byte 1 byte Stores whole numbers from -128 to 127 short 2 bytes Stores whole numbers from -32,768 to 32,767 int 4 bytes Stores whole numbers from -2,147,483,648 to 2,147,483,647 long 8 bytes Stores whole numbers from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 float 4 bytes Stores fractional numbers. Sufficient for storing 6 to 7 decimal digits double 8 bytes Stores fractional numbers. Sufficient for storing 15 decimal digits boolean 1 bit Stores true or false values char 2 bytes Stores a single character/letter or ASCII values Reference Type 종류 : String, Array, Classes 등 Primitive Type 외 모든 Data Type JVM Stack 영역에 주소값이 저장되고 실제 데이터 값은 Heap 영역에 존재 Null 가능 Non-primitive data type 이라고도 부름.마무리 Data Type에 대해 알아보면 그 다음 순서로는 JVM Memory 영역에 대해 빼놓을 수 없다." }, { "title": "Spring DispatcherServlet", "url": "/posts/spring-dispatcherServlet-01/", "categories": "Java, Spring", "tags": "java, spring, dispatcherServlet", "date": "2022-04-24 18:30:00 +0900", "snippet": " 해당 원글은 미디엄 블로그에서 작성한 내용을 해당 블로그에 기록하기 위해 가져옴.원글은 2021.06.30일 작성.개요 이번 주제는 DispatcherServlet이다. 흔히들 Front Controller라고도 부르는데 아무래도 Controller 앞단에서 Controller를 호출하는 역할을 해서 그런 것 같다.MVC 아래는 기본적인 MVC 패턴의 흐름이다.출처:https://stackoverflow.com/questions/2769467/what-is-dispatcher-servlet-in-spring 요청을 DispatcherServlet에서 받아서 Handler mapping으로 Controller 호출 Controller에선 응답을 수행 결과를 Model and logical view name으로 전달 ViewResolver는 view name을 확인하여 View를 전달 생성된 View를 Response로 전달DispatcherServlet DispatcherServlet은 간단하게 아래와 같이 동작한다.public class SimpleDispatcher extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse res) { // do get process(req.getRequestURI()); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse res) { // do post process(req.getRequestURI()); } public void process(String uri) { HandlerMapping handlerMapping = new HandlerMapping(); handlerMapping.init(); Controller controller = handlerMapping.getController(uri); controller.request(); }}public class HandlerMapping { Map&lt;String, Controller&gt; controllerMap = new HashMap&lt;&gt;(); public void init() { controllerMap.put(\"/login\", new LoginController()); } public Controller getController(String uri) { return controllerMap.get(uri); }}public class LoginController implements Controller{ @Override public void request() { // Do Something }} 간단하게 만들어 봤는데 실제와 비슷하지 않겠지만 대충 이런 흐름으로 동작한다고 보면된다. Spring에선 이러한 작업들을 딱히 신경 쓰지 않아도 제공해 주니 정말 편하게 구현할 수 있다.마무리어쨋든 DispatcherServlet도 Servlet이니 기본적인 동작은 Servlet으로 동작한다는 것을 알아두고 넘어가면 될 것 같다. 참고로 Spring DispatcherServlet은 Servlet관련 여러 추상클래스를 단계별로 상속받고 있다." }, { "title": "Spring Controller Post RequestBody with gson", "url": "/posts/spring-requestBody-01/", "categories": "Java, Spring", "tags": "java, spring, requestBody, json", "date": "2022-04-24 18:25:00 +0900", "snippet": " 해당 원글은 미디엄 블로그에서 작성한 내용을 해당 블로그에 기록하기 위해 가져옴.원글은 2021.06.25일 작성.RequestBody Json Spring Controller사용시 RequestBody를 통해 요청을 Json 타입(MediaType.APPLICATION_JSON_VALUE)으로 많이 사용한다. Json 이므로 key:value 형태로 값이 전달 될것이다. 하지만 RequestBody를 받는 것이므로 단순 String도 전달 가능하다. 아래 예시를 보자. @RestControllerpublic class RestTestController { @PostMapping(value = \"post\", consumes = MediaType.APPLICATION_JSON_VALUE) public String postRest(@RequestBody String text) { System.out.println(\"text : \" + text); return \"receive text : \" + text; }} 간단하게 문자열만 받아서 처리할 수 있는 형태이다. 기본적으로 Spring Boot는 메세지 컨버터를 이용해 RequestBody를 처리한다. Json default 메세지 컨버터는 MappingJackson2HttpMessageConverter이다.(2.5.1 기준)MessageConverter 기본으로 사용해도 좋지만 커스텀 메세지 컨버터를 사용하는 경우가 있을 수 있다. 그전에 GsonMessageConverter로 한번 바꿔보자. 방법을 참고한 사이트spring.http.converters.preferred-json-mapper=gson 이런방식으로 바꿔도 아무런 문제가 없다. gson이든 jackson이든 원하는 대로 동작한다. 이번엔 커스텀 gsonMessageConverter를 만들어보자. Config Class 작성하고@Configurationpublic class ApplicationConfig implements WebMvcConfigurer { @Override public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) { List&lt;HttpMessageConverter&lt;?&gt;&gt; result = new ArrayList&lt;&gt;(converters.size() + 2); Gson gson = new GsonBuilder().create(); System.out.println(\"inject custom converter\"); CustomGsonHttpMessageConverter gsonMessageConverter = new CustomGsonHttpMessageConverter(); gsonMessageConverter.setGson(gson); result.add(gsonMessageConverter); converters.clear(); converters.addAll(result); }} CustomGsonHttpMessageConverter 작성하고, (GsonHttpMessageConverter 클래스 그대로 모방)public class CustomGsonHttpMessageConverter extends AbstractJsonHttpMessageConverter { private Gson gson; public CustomGsonHttpMessageConverter() { this.gson = new Gson(); } public CustomGsonHttpMessageConverter(Gson gson) { Assert.notNull(gson, \"A Gson instance is required\"); this.gson = gson; } public void setGson(Gson gson) { Assert.notNull(gson, \"A Gson instance is required\"); this.gson = gson; } public Gson getGson() { return this.gson; } protected Object readInternal(Type resolvedType, Reader reader) throws Exception { System.out.println(\"이곳에서 요청을 처리.\"); return this.getGson().fromJson(reader, resolvedType); } protected void writeInternal(Object object, @Nullable Type type, Writer writer) throws Exception { System.out.println(\"이곳에서 응답을 처리.\"); if (type instanceof ParameterizedType) { this.getGson().toJson(object, type, writer); } else { this.getGson().toJson(object, writer); } }} 커스텀 컨버터는 Gson gson = new GsonBuilder().create(); 이렇게 Gson Library를 그대로 사용한다. 그리고 한번 테스트 해보자. 두둥!! 아래와 같은 오류가 발생한다.com.google.gson.stream.MalformedJsonException: Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 7 path $ 순수 gson library는 단순 String 형태를 convert할 때 문자열에 띄어쓰기가 존재하면 해당 오류를 내뱉는다.이렇게 띄어쓰기는 제대로 컨버트 되지 않는다. 아래와 같이 하나의 String으로 묶어주면 원하는대로 동작 가능신기하게도 응답도 묶여서 옴아까 기본 Jasckson 일때 비교짤 하나의 String으로 묶어서 전달하는 방법. Script를 예시로 들면 ‘“test text”’이렇게 전달. 아니면 key:value로 전달.마무리 커스텀 메세지 컨버터에 기본 gson library를 이용하는 경우에 발생할 수 있는 이슈에 대해 알아보았다. 이렇게 사용하는 일이 드물지만 만약 사용하는 경우 유의해서 사용해야한다." }, { "title": "Spring RequestMapping 3편", "url": "/posts/spring-mappings-03/", "categories": "Java, Spring", "tags": "java, spring, mapping", "date": "2022-04-24 18:15:00 +0900", "snippet": " 해당 원글은 미디엄 블로그에서 작성한 내용을 해당 블로그에 기록하기 위해 가져옴.원글은 2021.06.19일 작성.개요 3편까지 쓸 내용은 아닌데 이거 저거 부가적으로 추가하다 보니 3편까지 왔다. 3편은 Response이다. 내용이 길…짧..? 모르겠다 길어지면 4편까지 이어질지도…Response 우선 legacy Controller와 RestController의 차이점은 ResponseBody가 포함여부이다. Controller + ResponseBody = RestController 그래서 Controller에 ResponseBody가 붙이지 않고 그냥 string을 리턴하면 ViewResolver 설정에 의해 string에 해당하는 jsp page로 연결된다.@Controller@RequestMapping(\"/req\")public class RequestApiController { @RequestMapping(value = \"/home\") public String index() { return \"index\"; }}// application.propertiesspring.mvc.view.prefix=/WEB-INF/view/spring.mvc.view.suffix=.jsp Spring Boot ViewResolver 기본 of 기본 설정 참고한 사이트Spring 예시 Spring Boot라서 정말 간단하다. 참고한 사이트에선 ViewResolver 설정을 Configuration Annotation을 이용하여 설정하는 법에 대한 예시가 있는데 내가 설정한 Spring Boot 버전에선 implements 인터페이스 클래스가 deprecated된 클래스로 확인된다. 아래와 같이 설정 가능하다.@Configuration@EnableWebMvcpublic class MvcConfiguration implements WebMvcConfigurer { @Override public void configureViewResolvers(ViewResolverRegistry registry) { registry.jsp(\"/WEB-INF/view/\", \".jsp\"); }} 위 application.properties 설정이 더 간단하지만 필요에 따라 골라서 사용하면 될 것 같다. ViewResolver는 여기까지만 확인하자. 그래서 RestController에서 String을 return하면 그대로 문자열이 표시된다. 한가지 실험..?JSP 페이지 내용 그대로어느정도 표현은 된다. 옛날에는 이런방식으로도 개발을 했었다. 요즘엔 같이 일하는 동료를 부르고 싶다면 이렇게 작성한 뒤 commit 하면 된다.Response Json 다음은 가장 대중적인 json 방식으로 return해보자. json 방식으로 return 하려면 Key:Value 방식으로 VO를 return 해야한다. 간단하게 VO를 작성해보자. (아아 간단하지 않아…)public class JsonResult { @Getter private String val1; @Getter private String val2; public JsonResult(String val1, String val2) { this.val1 = val1; this.val2 = val2; } @Override public int hashCode() { int val1Hash = val1 != null ? val1.hashCode() : 0; int val2Hash = val2 != null ? val2.hashCode() : 0; return val1Hash + val2Hash; } @Override public boolean equals(Object o) { if (this == o) { return true; } if (o == null || getClass() != o.getClass()) { return false; } JsonResult that = (JsonResult) o; if (val1 == null || val2 == null) { return false; } return ((JsonResult) o).getVal1().equals(this.getVal1()) &amp;&amp; ((JsonResult) o).getVal2().equals(this.getVal2()); }} RestController에서 만든 VO를 return하도록 해보자@GetMapping(\"/cash\")public JsonResult getCash(String num) { System.out.println(\"num : \" + num); return new JsonResult(\"val1\", num);} Spring에서 MessageConverters가 자동으로 content-type에 따라 지정되어 response혹은 request를 처리한다. produces 기본이 Json이므로 잘 동작하는 것을 확인 할 수 있다. 마무리 json을 가장 많이 쓰므로 여기까지만 알아보도록 하자. 4편이 나올수도 있고 아닐 수도 있는데 관련있으면 4편으로 하고 아니면 새로운 제목으로 다시 시작할 수 있다. 결론은…? Response를 전달할때 어떠한 content-type으로 전달할지 잘 생각하고 그에 맞게 Convert되도록 해줘야 한다는 걸 잊지말자." }, { "title": "Spring RequestMapping 2편", "url": "/posts/spring-mappings-02/", "categories": "Java, Spring", "tags": "java, spring, mapping", "date": "2022-04-24 18:05:00 +0900", "snippet": " 해당 원글은 미디엄 블로그에서 작성한 내용을 해당 블로그에 기록하기 위해 가져옴.원글은 2021.06.14일 작성.개요 2편은 Controller에 값을 전달 받는 방법 확인하기.Controller 4가지 annotation을 사용하는게 가장 일반적이다. RequestParam RequestBody ModelAttribute PathVariableRequestParam 우선 RequestParam 방식. 간단하게 값을 받을 때 유용하게 사용된다.@GetMapping(\"/cash\")public String getCash(@RequestParam String num) { System.out.println(\"num : \" + num); return \"get\";}//http://localhost:8080/cash?num=2//num : 2 annotation 생략도 가능하다.@GetMapping(\"/cash\")public String getCash(String num) { System.out.println(\"num : \" + num); return \"get\";} Object로 값을 전달받는 방법이 있는데 annotation 없이 사용하면 어떻게 될까? 아래와 같이 Class를 하다 만들고 Get 방식으로 값을 받아보자.public class CashParam { @Getter int num; @Getter String account;}...@GetMapping(\"/cash\")public String getCash(CashParam param) { System.out.println(\"param : \" + param.getNum()); return \"get\";} 아까와 같은 방식으로 (cash?num=2) 전달하면 원하는대로 동작하지 않는다 그 이유는 int num 변수에 Setter가 없기 때문이다. annotation을 생략하면 또 자동으로 ModelAttribute 방식으로 동작한다는 것을 알 수 있다.public class CashParam { @Getter @Setter int num; @Getter String account;}RequestBody 그렇다면 RequestBody로 지정을 해보자.@GetMapping(\"/cash\")public String getCash(@RequestBody String num) { System.out.println(\"num : \" + num); return \"get\";}두둥! RequestBody는 말그대로 HttpRequest Body의 값을 받아오는 것이므로 Body가 없는 Get방식에는 사용할 수 없다. 다음은 PathVariable. 이렇게 간단하게 사용할 수 있다.@GetMapping(\"/cash/{num}\")public String getCash(@PathVariable String num) { System.out.println(\"num : \" + num); return \"get\";}마무리 Controller에 값을 전달하는 다양한 방법을 알아 봤는데 하나의 메서드에 다양한 annotation을 적절히 섞어서 사용하면 된다.참고한 블로그 — https://mangkyu.tistory.com/72" }, { "title": "Spring RequestMapping 1편", "url": "/posts/spring-mappings-01/", "categories": "Java, Spring", "tags": "java, spring, mapping", "date": "2022-04-24 18:05:00 +0900", "snippet": " 해당 원글은 미디엄 블로그에서 작성한 내용을 해당 블로그에 기록하기 위해 가져옴.원글은 2021.06.11일 작성.Mappings이번 주제는 Srping 4.3 부터 추가된 RequestMapping의 축약?형 xxMapping 어노테이션이다. GetMapping PostMapping PutMapping DeleteMapping PatchMapping RestController에 최적화 된 어노테이션. Http 메서드 이름으로 바로 구분이 가능하다.Spring 예제 아래는 Spring Boot로 바로 만들어본 RestContoller. Get 메서드를 하나 추가해봤다.@RestControllerpublic class RestApiController { @GetMapping(\"/\") public String index() { return \"index\"; }} http://localhost:8080/ 로 바로 접속하면 확인 가능하다 Get 메서드이니까. 해당 Controller에 Get, Post, Put, Delete, Patch 메서드 모두 추가해보자. @GetMapping(\"/cash\")public String getCash(){ return \"get\";}@PostMapping(\"/cash\")public String postCash(){ return \"post\";}@PutMapping(\"/cash\")public String putCash(){ return \"put\";}@DeleteMapping(\"/cash\")public String deleteCach(){ return \"delete\";}@PatchMapping(\"/cash\")public String patchCash(){ return \"patch\";} 각 메서드 사용법중 Put과 Patch가 겹치는데 보통 Put은 전체 정보를 수정하는 것이라면 Patch는 지정된 정보만 수정하는 차이가 있다고 한다.확인 Postman을 활용하여 각 메서드마다 수행해보자.다양한 메서드를 제공한다GetPostPut 나머지 메서드는 생략하자. 위 예시와 같이 동일한 Url이 다양한 메서드를 통해 각기 다른 작업을 수행할 수 있다. 이거슨 바로 Rest Api 그렇다면 위와 동일한 수행을 하는 RequestMapping 어노테이션을 작성해보자. //@Controller@RestControllerpublic class RequestApiController { @RequestMapping(\"/index\") public String index() { return \"req index\"; }} Controller 안되는 이유 검색해본 결과 결론 @ResponseBody가 빠짐.RestController -&gt; Controller + ResponseBody일반적으로 MVC이기 때문에 View Page로 이동을 시키는데 ResponseBody는 직접 Body에 값을 전달하기 때문에 View Page와 연결하지 않고 Text가 그대로 전달됨. 어쨋든 RequestMapping은 기본 메서드가 Get이기 때문에 /index로 접속하면 아래와 같이 잘 동작한다.한시간 삽질의 결과 아래와 같이 POST로 지정을 하고 브라우저로 접속하면There was an unexpected error (type=Method Not Allowed, status=405).에러가 발생한다.@RestControllerpublic class RequestApiController { @RequestMapping(value = \"/index\", method = RequestMethod.POST) public String index() { return \"req index\"; }} 그럼 나머지 메서드도 다 추가해보자.@RequestMapping(value = \"/cash\", method = RequestMethod.GET)public String getCash() { return \"req get\";}@RequestMapping(value = \"/cash\", method = RequestMethod.POST)public String postCash() { return \"req post\";}@RequestMapping(value = \"/cash\", method = RequestMethod.PUT)public String putCash() { return \"req put\";}@RequestMapping(value = \"/cash\", method = RequestMethod.DELETE)public String deleteCash() { return \"req delete\";}@RequestMapping(value = \"/cash\", method = RequestMethod.PATCH)public String patchCash() { return \"req patch\";} 결과를 확인해보자GETPatch 일단 RestController로 RequestMapping과 4.3에서 새롭게 제공된 GetMapping, PostMapping 등 기본적인 사용법에 대해 알아봤다.마무리 하지만 아직 갈 길이 멀다. RequesParam, RequestBody 등 Controller 요청에 값을 전달하는 방법도 알아봐야 한다. 다음은ParameterResponse순서대로 Controller를 파헤쳐 보도록 하자. 1탄 End." }, { "title": "Java Stream groupingBy", "url": "/posts/java-groupingBy-01/", "categories": "Java", "tags": "java, stream, groupingBy", "date": "2022-04-24 17:55:00 +0900", "snippet": " 해당 원글은 미디엄 블로그에서 작성한 내용을 해당 블로그에 기록하기 위해 가져옴.원글은 2021.05.28일 작성. 지난 달 글을 4월에 올린 것 같은데 너무 글을 안올린 것 같아서 급하게 하나 작성한다.개요 그간 이직 준비를 하느라 코테를 연습했는데 하다보니 사용할 만한 Stream 기능이 있어서 기록해 두려고 한다. 그거슨 바로바로 groupingBy!groupingBy API 문서에는 아래와 같이 나와있다.(https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html) 일단은 간단하게 알아보자. T 유형의 입력 요소에 대해 “group by ”작업을 구현하고 분류 함수에 따라 요소를 그룹화하고 결과를 맵에 반환하는 Collector를 반환합니다. 무슨말인고~?예제 예제를 통해 아라보자. 아래와 같은 Integer List가 있다. 각 숫자별로 그룹을 지어서 Map형으로 변환 하고 싶다. 1={1}, 2={2,2} 이런식으로List&lt;Integer&gt; testList = Arrays.asList(1,2,3,4,5,6,7,5,3,2,5,5,7,8,5,4,3,3,4,6,7); Stream groupingBy를 이용하면 아주 쉽게 만들 수 있다.Map&lt;Integer, List&lt;Integer&gt;&gt; testMap = testList.stream() .collect(Collectors.groupingBy(i -&gt; i));// testMap : {1=[1], 2=[2, 2], 3=[3, 3, 3, 3], 4=[4, 4, 4], 5=[5, 5, 5, 5, 5], 6=[6, 6], 7=[7, 7, 7], 8=[8]} 엄청 쉽죠잉~? 이상 코테에서나 쓸법한 예제였다. 그룹화 다음은 Class List를 그룹화 해보자, 그나마 실무에 적용할만하다. 예를 들어 쉽게 아래와 같은 class를 정의하자static class Student { String name; String subject; public Student(String name, String subject) { this.name = name; this.subject = subject; }}List&lt;Student&gt; students = new ArrayList&lt;&gt;();students.add(new Student(\"강\", \"수학\"));students.add(new Student(\"강\", \"과학\"));students.add(new Student(\"강\", \"영어\"));students.add(new Student(\"강\", \"국어\"));students.add(new Student(\"김\", \"수학\"));students.add(new Student(\"김\", \"과학\"));students.add(new Student(\"박\", \"언어\"));students.add(new Student(\"박\", \"경제\"));students.add(new Student(\"박\", \"토익\")); 학생이 듣는 과목을 묶어서 Map으로 만들어보자Map&lt;String, List&lt;Student&gt;&gt; studentSub = students.stream() .collect(Collectors.groupingBy(Student::getName));// {김=[김 : 수학, 김 : 과학], 박=[박 : 언어, 박 : 경제, 박 : 토익], 강=[강 : 수학, 강 : 과학, 강 : 영어, 강 : 국어]} 여기서 value의 Student를 subject로 바꾸는 방법을 찾고 있는데 고민을 좀 해보고 있다.Map&lt;String, List&lt;String&gt;&gt; results = studentSub.entrySet().stream().collect(Collectors.toMap( e -&gt; e.getKey(), e -&gt; e.getValue().stream() .map(Student::getSubject) .collect(Collectors.toList()))); 이런식으로 할 수 있으나 가독성도 좋지 않고 좀 길다.마무리어쨋든 코테에서 사용해 볼 수 있는 groupingBy에 대해 간단히 알아봤다. 심화 과정은 시간이 좀 나면 작성해보자." }, { "title": "파이썬 데이터 관리", "url": "/posts/python-03/", "categories": "Python", "tags": "python, data, array, tuple, dictionary", "date": "2022-04-23 20:20:00 +0900", "snippet": " 해당 원글은 미디엄 블로그에서 작성한 내용을 해당 블로그에 기록하기 위해 가져옴.원글은 2021.04.18일 작성.개요 헷갈리는 부분에 봉착했다. Array, Tuple, Dictionary Array는 어느정도 알겠는데 Tuple, Dictionary가 헷갈린다. 일단 하나하나 알아보자Array 선언 및 초기화는 다른 언어와 같다stock_list = []stock_list2 = ['123', '234', '567'] 뭐 알다시피 접근은 index 0부터print(stock_list2[2])# 567 두 Array 합치기stock_list = ['000', '111']stock_list2 = ['123', '234', '567']stock_list.append(stock_list2)print(len(stock_list))print(stock_list)#3#['000', '111', ['123', '234', '567']] 이렇게 단순히 append 해버리면 파이썬은 2차원 배열이 되어버린다. numpy를 이용하면 원하는대로… 코드가 좀 길어지지만 이방법 말고 는 없는 것 같다.stock_list = ['000', '111']stock_list2 = ['123', '234', '567']stock_list = np.append(stock_list, np.array(stock_list2))#['000' '111' '123' '234' '567'] 그 밖에 insert, del, pop, remove 기본 Array 함수가 있는 듯 하나, numpy를 쓸 거 같다.Tuple 기본형은 Array와 다르게 ()이다.tuple1 = ()tuple2 = ('a',)tuple3 = 'a', 'b', 'c'tuple5 = ('a', 'b', ('c', 'd')) Array와 가장 다른 점은 값이 변하지 않는다는 것이다. 고정값을 사용할 때 Tuple을 사용하면 된다. 선언이 특이한 점이 값이 하나일 경우 ‘,’ 값을 뒤에 붙여야 한다고 한다. 그리고 ()없이도 선언이 가능함. 어쨋든 잘 안쓸 거 같음tuple2 = ('a',)tuple3 = ('b',)tuple4 = ('c',)print(tuple2 + tuple3 + tuple4)#('a', 'b', 'c') Tuple은 더하기가 되네… 신기하다.print((tuple2 + tuple3) * 2)#('a', 'b', 'a', 'b') 곱하기도 됨.Dictionary Java의 map이랑 비슷한 듯. 초기화dic1 = {\"a\": \"123\", \"b\": \"123\", \"c\": \"456\"}print(f'd[\"a\"] = {dic1[\"a\"]}')print('d[\"a\"] = ' + dic1[\"a\"])print('d[\"a\"] = ' + dic1.get(\"a\"))# d[\"a\"] = 123# d[\"a\"] = 123# d[\"a\"] = 123 value는 key 값으로 접근. [key]로 접근시 값이 없으면 에러, get(key)로 접근시 없으면 None. 그러므로 get으로 접근하는 것이 좋습니다. key는 unique. immutable 값. mutable한 list나 dictionary값은 안됨. tuple은 됨.dic1[\"d\"] = \"d value\"print(dic1)dic1[\"d\"] = \"d mod value\"print(dic1)dic1.update(d=\"dmod\")print(dic1)del dic1[\"d\"]print(dic1)dic1.clear()print(dic1)# {'a': '123', 'b': '123', 'c': '456', 'd': 'd value'}# {'a': '123', 'b': '123', 'c': '456', 'd': 'd mod value'}# {'a': '123', 'b': '123', 'c': '456', 'd': 'dmod'}# {'a': '123', 'b': '123', 'c': '456'}# {} 값 추가는 새로운 key를 지정하여 값을 설정할 수 있음. 동일한 key를 지정하여 값을 설정하면 기존 값이 수정됨 update를 통해 key값 수정 가능 del을 통해 key: value 삭제 clear는 dictionary 초기화for d in dic1.items(): print(d) print(d[0]) print(d[1])for k in dic1.keys(): print(k)for v in dic1.values(): print(v)('a', '123')a123('b', '123')b123('c', '456')c456abc123123456 for문으로 dictionary 값에 접근하는 방법. 파이썬은 대체로 심플하게 가능하다.마무리numpy가 파이썬 배열 관련 대표 library인 것 같은데 다음번에 한번 알아봐야겠다." }, { "title": "파이썬 Log, File", "url": "/posts/python-02/", "categories": "Python", "tags": "python, log, file", "date": "2022-04-23 20:00:00 +0900", "snippet": " 해당 원글은 미디엄 블로그에서 작성한 내용을 해당 블로그에 기록하기 위해 가져옴.원글은 2021.04.13일 작성.개요 지난번 파이썬 시작하기에 이어 Log 설정, File 혹은 Path 관리하기에 대해 알아보자.File 우선 Log를 File에 기록하기 위해선 File 경로나 File명을 기본적으로 설정하는 법을 알아야한다.두 가지 모듈을 import 해보자import osimport sys 현재 File 위치를 알아내어 현재 디렉토리 경로를 찾을 수 있다.BASE_DIR = os.path.dirname(os.path.abspath(__file__)) 현재 디렉토리를 이용해 log가 저장 될 디렉토리를 생성해보자.output = os.path.join(BASE_DIR, 'logs')if not os.path.isdir(output): os.makedirs(output) 이런식으로 간단하게 디렉토리가 없으면 생성할 수 있다.Logimport logging log가 저장될 디렉토리가 만들어졌으면 logging.FileHandler를 통해 log가 저장될 File을 지정할 수 있다. log level도 설정할 수 있음. 매우 간단하다 레알fileName = 'python.log'file_handler = logging.FileHandler(filename=os.path.join(output, fileName), encoding='utf-8')file_handler.setLevel(logging.DEBUG) sys.stdout은 그냥 출력 하고 log level 또한 설정 가능하다.stream_handler = logging.StreamHandler(sys.stdout)stream_handler.setLevel(logging.INFO) 그리고 log format 또한 설정이 가능하다.FORMAT = '%(asctime)-15s %(message)s'logging.basicConfig(format=FORMAT, handlers=[file_handler, stream_handler], level=logging.DEBUG) 이렇게 log 설정 한 뒤 한번 기록해보자.logging.info('로깅 info')logging.debug('logging 디버그')이것저것 시도해 봄 이런식으로 log를 file로 기록해서 사용할 수 있으니 강화학습 테스트에 활용해 볼 수 있겠다.파이썬 logging 가이드" }, { "title": "파이썬 시작하기", "url": "/posts/python-01/", "categories": "Python", "tags": "python", "date": "2022-04-23 20:00:00 +0900", "snippet": " 해당 원글은 미디엄 블로그에서 작성한 내용을 해당 블로그에 기록하기 위해 가져옴.원글은 2021.04.10일 작성.개요 이전 글 주제가 자동 투자 봇 만들기였는데 이러저러해서 결국 중간에 마무리 되었다. 그렇다고 자동 투자 봇 만들기를 포기한건 아니다. 다시 처음부터 차근차근 진행해 보려고한다. 그래서 생각한 첫째 단계가 파이썬 시작하기다. 파이썬 딥러닝, 머신러닝, 강화학습 관련하여 여러가지 책을 읽어봤는데 이게 도통 이해가 잘 안되더라. 그래서 파이썬부터 익숙해 지기로 하였다.파이썬 코드 시작 PyCharm으로 새 프로젝트를 생성하면 아래와 같이 생성된다.이게 파이썬 월드라니 파이썬 코드 처음 시작은 __main__ 여기서부터 시작된다. 이부분이 뭔지 간략히 알아보자.if __name__ == '__main__' 만약 __name__이 __main__이라면! __name__ 변수엔 각 모듈의 이름이 들어가게 된다. hello.py 면 값이 ‘hello’. school.py면 값이 ‘school’. 하지만 이것은 다른 모듈에서 import 되어 불러졌을 때의 값이고 해당 모듈이 인터프리터 시작점이라면 __main__ 값이 들어가게 된다. 그렇다. __main__ 값은 시작점이라고 생각하면 쉽다.Argparseimport argparse 그렇습니다. ArgumentParser입니다. 실행시 옵션 값을 붙일 수 있습니다. 쓰임새가 매우 다양하여 내용이 길어질 것 같네요. 짧게 끝내도록 하죠.if __name__ == '__main__': parser = argparse.ArgumentParser() parser.add_argument('--foo', help='foo help') args = parser.parse_args() 파이썬 가이드 문서에 나온대로 함 해봅니다.&gt; python main.py — helpusage: main.py [-h] [ — foo FOO]optional arguments:-h, — help show this help message and exit— foo FOO foo help 오 옵션 사용법을 이렇게 help로 명시할 수 있네요. 좋군요parser.add_argument('--man', nargs='+')&gt; python main.py — man oneman twoman threemanonemantwomanthreeman 옵션에 여러 값을 넣고 싶을 땐 nargs를 이용하면 되네요parser.add_argument('--use', choices=['Y', 'N'], default='N')&gt; python main.pyN&gt; python main.py — use YY&gt; python main.py — use Kusage: main.py [-h] [ — foo FOO] [ — use {Y,N}]main.py: error: argument — use: invalid choice: ‘K’ (choose from ‘Y’, ‘N’) 옵션 값을 고정 된 값으로 지정할 수도 있습니다.parser.add_argument('--num', type=int, default=100)&gt; python main.py — num 11&gt; python main.py — num testusage: main.py [-h] [ — foo FOO] [ — num NUM]main.py: error: argument — num: invalid int value: ‘test’ 타입도 지정할 수 있네요. 잘 활용한다면 실행할 때 마다 다양한 방식으로 동작하도록 만들 수 있을 것 같네요~ 자세한 내용은 파이썬 가이드 문서를 확인해 보세요~argparse — 명령행 옵션, 인자와 부속 명령을 위한 파서 — Python 3.8.9 문서 한글판이라니… 가이드 문서가 한글판이라니!!" }, { "title": "한국투자증권 모바일 API 활용하기 2탄", "url": "/posts/hantoo-api-02/", "categories": "Mobile, API, Netty", "tags": "mobile, api, netty", "date": "2022-04-23 19:47:00 +0900", "snippet": " 해당 원글은 미디엄 블로그에서 작성한 내용을 해당 블로그에 기록하기 위해 가져옴.원글은 2021.03.13일 작성.개요 하다가 2탄을 할까 말까 고민을 좀 했었다. 이유인 즉슨 한투 모바일API는 가이드도 제대로 되어있지 않고 자동 투자를 위해 필요한 정보가 좀 부실하기 때문이다. 특히, 내 잔고를 불러오는 코드가 ‘satps’인데 가이드에 나와있지 않다. 샘플코드에만 나와있다… 이럴거면 가이드는 대체 왜 만든건지… 그리고 한가지 더. 모투에선 잔고가 조회되지 않는다. (실전은 됨) 상태 정보에 실제 잔고를 포함해서 테스트 해보고 싶었는데 그게 안된다. 물론 현재가만 가져오는 용도로 사용해도 되긴 하지만 그러기엔 너무 오버스펙이다. 그래도 작성한 것은 마무리하기 위해 2탄으로 돌아오게 되었다.목표 2탄의 목표는 지난번에 언급했듯이 응답을 Json으로 바꾸고 모든 API를 등록하는 것이었다. Json으로 바꾸는 부분은 중요하지 않기 때문에 뒤로 넘어가고 현재가를 가져오는 API 작성하는 부분부터 진행해 보겠다. 1탄에서 아래와 같이 이미 제공된 CommExpertMng 클래스를 이용하여 간단하게 계정정보를 가져오는 부분까지 작성했었다. 제공된 클래스를 이용하기 때문에 코드가 길어질일이 없었는데…AccountNo(\"getAccountNo\") { @Override public String getResult(String... params) { String index = params[0]; String strAcc = CommExpertMng.getInstance().GetAccountNo(Integer.parseInt(index)); JsonObject jsonObject = new JsonObject(); jsonObject.toString().getBytes(StandardCharsets.UTF_8); jsonObject.addProperty(\"result\", String.valueOf(strAcc)); return jsonObject.toString(); }}, 기본적으로 한투 모바일 API의 데이터 주고 받는 방식이 Listener 방식이었다. 데이터를 요청하면 Override된 received 메소드로 데이터가 넘어오는 식이었는데 이방식으로 인해 요청에 딜레이가 발생할 수 밖에 없었다. 다행히 오래걸리지는 않아서 사용할 만한 수준이었다.이렇게 요청을 하면m_nPrcieRqId = m_PriceTranProc.RequestData(reqCode);요기서 데이터를 받아올 수 있다.@Overridepublic void onTranDataReceived(String s, int i) { StockDataMaker dataMaker = new StockDataMaker(); if (StringUtils.equals(\"scp\", s)) { currentData = dataMaker.generateCurrentData(m_PriceTranProc); } else if (StringUtils.equals(\"scpc\", s)) { conclusionList = dataMaker.generateConclusionData(m_PriceTranProc); } else if (StringUtils.equals(\"scpd\", s)) { dayList = dataMaker.generateDayData(m_PriceTranProc); } wait = false;} 샘플코드에 다 나와있으므로 자세한 건 넘어가겠다. 그냥 싱글톤 클래스 만들어서 제공해줬으면 편했을텐데… ㅠㅠ 실시간 데이터의 경우 또 조금 다른데 요청을 시작하면 received 메소드에서 계속 실시간으로 데이터를 받을 수 있다. 그 데이터를 통해 호가창을 만들고 그래프를 그리고 할 수 있다. 자동 투자하는데 실시간까진 필요가 없으니…우여곡절못해묵겄어! 위에서 언급했듯이 잔고 가져오는 서비스를 만들다가 중단했는데 그 이유가 모투에서는 잔고를 가져올 수 없었기 때문이다. 내가 뭔가 잘 못 했겠지… 하면서 이것저것 시도해 봤는데 안되길래 혹시나 해서 퓨어한 샘플코드로 해봤는데 안되더라. 한투 홈피 드가서 물어볼까 했는데 귀찮아서 관둠… 자산 조회 API에서 막히니 굳이 매수매도까지…? 라는 생각이 들어서 포기…어찌 할 수 없는 라이브러리 오류아무것도 할 수 없는 겨JSON json 별거 없다 gson 사용했다.if (StringUtils.equals(\"scp\", reqCode)) { return new Gson().toJson(currentData).toString();} else if (StringUtils.equals(\"scpc\", reqCode)) { return new Gson().toJson(conclusionList).toString();} else if (StringUtils.equals(\"scpd\", reqCode)) { return new Gson().toJson(dayList).toString();} 활용하려고 했던 현재가 불러오기{\"accessibility\":\"000000000.00\",\"accumulateAmount\":\"000000000013530573\",\"accumulateTrade\":\"000001121128514600\",\"averagePrice\":\"0000000000082861.97\",\"beMaxPrice\":\"0000096800\",\"beMaxPriceDay\":\"20210111\",\"beMinPrice\":\"0000042300\",\"beMinPriceDay\":\"20200319\",\"bps\":\"00039406.00\",\"capital\":\"0000000000000000007780\",\"capitalName\":\"7,780 억\",\"eps\":\"00003841.00\",\"facePriceName\":\"100\",\"faceValue\":\"00000000100\",\"foreignBuy\":\"000002116847\",\"foreignTotalCount\":\"000000003265821004\",\"htsBuyAmountUnit\":\"0000000001\",\"htsForeignRate\":\"00054.71\",\"limitWidth\":\"0000024550\",\"loanRate\":\"00000.16\",\"lowerLimit\":\"0000057400\",\"marketCapitalization\":\"000000000004942980\",\"maxPrice\":\"0000083500\",\"minPrice\":\"0000082400\",\"pbr\":\"00002.10\",\"per\":\"00021.56\",\"pivotPoint\":\"0000081833\",\"pivotResist2\":\"0000083333\",\"pivotResits1\":\"0000082666\",\"pivotSupport1\":\"0000081166\",\"pivotSupport2\":\"0000080333\",\"price\":\"0000082800\",\"price2\":\"0000083100\",\"programBuy\":\"000000000000699509\",\"quoteUnit\":\"0000000100\",\"referencePrice\":\"0000082000\",\"resistValue\":\"0000083000\",\"settleMonth\":\"12\",\"shortSellingYn\":\"N\",\"shortStockCode\":\"005930\",\"stockCount\":\"000000005969782550\",\"substitute\":\"0000065600\",\"supportValue\":\"0000081500\",\"thanBeMaxPriceRate\":\"-0014.46\",\"thanBeMinPriceRate\":\"00095.74\",\"thanCode\":\"2\",\"thanPrice\":\"0000000800\",\"thanRate\":\"00000.98\",\"thanTradeRate\":\"00056.81\",\"thanWeekMaxPriceRate\":\"-0014.46\",\"thanWeekMinPriceRate\":\"00095.74\",\"thanYearMaxPriceRate\":\"-0014.46\",\"thanYearMinPriceRate\":\"00003.24\",\"turnover\":\"00000.23\",\"upperLimit\":\"0000106500\",\"weekMaxPrice\":\"0000096800\",\"weekMaxPriceDay\":\"20210111\",\"weekMinPrice\":\"0000042300\",\"weekMinPriceDay\":\"20200319\",\"yearMaxPrice\":\"0000096800\",\"yearMaxPriceDay\":\"20210111\",\"yearMinPrice\":\"0000080200\",\"yearMinPriceDay\":\"20210104\"} 요고 계속 불러다가 상태값으로 써서 강화학습 해볼까 했는데… 아숩마무리 한투모바일은 여기까지가 끝인가보오…쓰시는분들이 얼마나 있을지 모르겠지만 이런식으로 쓰시려는 분 있으면 말리고 싶다. 한투모바일 멈춰!다음으로 파이썬 공부하면서 자동 투자는 키움의 도움을 받으려고 한다.키움 API 고수분들 도움!마무리 1탄에서도 언급했지만, 한국투자증권에서 Rest api를 도입했다. 이 포스팅은 역사 속으로…" }, { "title": "한국투자증권 모바일 API 활용하기 1탄", "url": "/posts/hantoo-api-01/", "categories": "Mobile, API, Netty", "tags": "mobile, api, netty", "date": "2022-04-23 19:47:00 +0900", "snippet": " 해당 원글은 미디엄 블로그에서 작성한 내용을 해당 블로그에 기록하기 위해 가져옴.원글은 2021.02.19일 작성.개요 자동 투자 봇을 만들어 보려고 한다. 다양한 증권사 중 한국투자증권(이하 한투)으로 결정한 이유는 이미 계좌가 개설되어 있기 때문이다. 매우 단순한 이유지만 사실 모바일 API를 지원하지 않았으면 대표 적인 증권사인 키움이나 대신으로 넘어갔을지도 모른다. 한투의 기본 COM방식(?)은 OpenAPI 예제가 없어도 너무 없었다. 여러가지 고민을 했었는데 모바일이라면 쉽게 접근할 수 있을 것 같아서 시작해보려고 한다. 생각대로 안되면 때려 치우고 결국 새롭게 계좌 개설 하러 갈지도 모름.. 참고로 한국투자증권 Rest API가 출시됨.. 해당 포스트 보러 오신분은 얼른 이 페이지에서 나가주세요. 그럼 처음부터 차근차근 시작해 보자. 전략은 간단하다. 한투 모바일 API 앱내에 Netty Framework이용하여 Http 서버를 만들고, 파이썬으로 서버에 접근하여 모바일 API를 간접적으로 호출하는 것이다.1. 한투 모바일 API를 받아보자. 모바일로 써있는 건 모두 받자2. 세가지 파일 모두 압축을 풀어보자 가이드 파일은 API 사용법에 대해 잘 나와있으니 계속 확인을 해야한다. CommExpert_mobile 이라고 Open API 프로그램이 있는데 딱히 필요는 없다.중요한 건 샘플 프로그램이다. 이 샘플 프로그램을 Android Studio로 열어보자. 아래 그림과 같은 구조의 프로그램을 확인할 수있다.CommExpert 모듈이 증권사에서 제공하는 Open API 모듈로 가장 핵심적인 부분이라고 할 수있다.OpenApiSample 모듈은 CommExpert를 이용한 간단한 앱 예제이다. 이 프로젝트 그대로 앱을 실행하면 매우 심플한 화면을 만날 수 있다. 앱이라서 여러가지 화면들로 구성되어있다.3. 샘플 프로그램 수정 샘플 프로그램 그대로 사용해도 상관은 없다. 하지만 난 앱 내의 서버만 잘 올라가면 되기 때문에 화면구성은 메인화면을 제외하고 다 삭제해버렸다. 화면 구성 외에 다른 것들은 건드릴 필요가 없어서 그대로 두고 필요없는 것은 모두 삭제한 뒤 다시 테스트를 해본다. 그렇게 완성된 프로젝트는 아래 그림과 같다. 이렇게 완성되기까지 꽤 많은 시행착오를 거쳤다. 안드로이드 프로그래밍 숙련자라면 쉽게 완성할 수 있을 것이다. 간단히 만든 예제 참고로 그냥 시작하면 공인인증서 파일이 없다는 알럿이 뜬다. 에뮬내에 공인인증서를 넣어주면 해결될 것 같지만 에뮬레이터에선 잘 안되니 테스트용도로만 사용하자. 실제 안드로이드 폰에 설치해서 확인해본 결과 공인인증서만 잘 넣어놓으면 공인인증서 로그인도 잘 된다. 사고 팔고 하려면 필요하니 로그인 할 수 있도록 하자. 몰랐는데 안드로이드 sdcard 디렉토리를 보면 NPKI 디렉토리가 친절하게 잘 구성되어 있더라…4. Netty 서버 구축 앱이 로딩이 되면 서버가 바로 시작되어야하기 때문에 적절한 곳에 서버 시작 프로세스를 추가했다.@Overridepublic void onInitFinished() { // TODO Auto-generated method stub Toast.makeText(this, \"초기화 성공\", Toast.LENGTH_SHORT).show(); StartServer startServer = new StartServer(); startServer.startServer(); CommExpertMng가 초기화 되고 로그인 시작 전에 서버 시작한다. Netty Http 서버는 github 예제에서 그대로 가져와 사용했다.(netty 사랑합니다.) netty github Port는 전세계 기본 port 8080 서버가 구동되고 adb port forward를 통해 8080 port를 연결한뒤 127.0.0.1:8080에 접속하면 Hello world를 만날 수 있다.안녕 월드5. Netty SimpleChannelInboundHandler Netty가 중요한게 아니니 간단히 어떻게 활용했는지만 작성해본다.SimpleChannelInboundHandler를 상속받은 Class를 확인해보자 HttpRequest가 중요하다. HttpRequest Class를 확인해보면 uri를 받아올 수 있는데 이걸 활용하여 apiName과 parameter를 구분할 것이다. 예를 들면 127.0.0.1:8080/getAccountNo/1 이런식으로 호출하면 getAccountNo가 apiName이고 1을 parameter로 활용하는것이다. apiName으로 필요한 요청을 구분하고 요청에 필요한 parameter를 전달한다. 간단하게 enum으로 작성해 봤다.일단 무식하게 짠 코드HttpRequest req = (HttpRequest) msg;Log.d(TAG, \"uri : \" + req.uri());ApiCommand apiCommand = null;String params = \"\";String mainUri = StringUtils.substring(req.uri(), 1);if (StringUtils.isNoneBlank(mainUri)) { String[] paramList = mainUri.split(\"/\"); if (paramList.length == 1) { apiCommand = ApiCommandFactory.INSTANCE.getApiCommand(paramList[0]); } else if (paramList.length == 2) { apiCommand = ApiCommandFactory.INSTANCE.getApiCommand(paramList[0]); params = paramList[1]; }}String result = \"no Result\";if (apiCommand != null) { if (StringUtils.isNoneBlank(params)) { result = apiCommand.getResult(params.split(\",\")); } else { result = apiCommand.getResult(params); }}Log.d(TAG, \"api result : \" + result);ApiCommand Enumpublic enum ApiCommand { AccountSize(\"getAccountSize\") { @Override public String getResult(String... params) { int nCount = CommExpertMng.getInstance().GetAccountSize(); return String.valueOf(nCount); } }, AccountNo(\"getAccountNo\") { @Override public String getResult(String... params) { String index = params[0]; String strAcc = CommExpertMng.getInstance().GetAccountNo(Integer.parseInt(index)); return strAcc; } }, AccountCode(\"getAccountCode\") { @Override public String getResult(String... params) { String index = params[0]; String strAccCode = CommExpertMng.getInstance().GetAccountCode(Integer.parseInt(index)); return strAccCode; } }, AccountName(\"getAccountName\") { @Override public String getResult(String... params) { String index = params[0]; String strAccName = CommExpertMng.getInstance().GetAccountName(Integer.parseInt(index)); return strAccName; } };} api가 추가될 수록 enum 클래스 내용이 길어지겠지만, 딱히 유지보수 할 내용도 없고 해서 간단하게 가려고 한다.테스트로 호출해보니 잘 돌아간다.계좌 2개 잘있음 favicon.ico는 브라우저에서 테스트를 해서 그런 것 같고 앞으로 파이썬에서 테스트 하면 호출 안될 것 같다.그래서 앞으로의 과제는 응답을 text/plain으로 보내고 있는 부분을 application/json으로 바꾸기 필요한 api 모두 등록하기 파이썬에서 호출 테스트 해보기마무리 이렇게만 완성하면 본격적으로 파이썬을 이용한 자동 투자 봇을 만들 수 있을 것 같다. 여기까지 만드는 데 퇴근 후 짬짬히 시간내어 3~4일정도 걸린 것 같은데 앞으로 파이썬 공부하면서 완성하려면 정말 긴 여정이 될 것 같다… 일 때려치우고 여기에 매달릴 수도 없고 ㅠ 찬찬히 진행해서 2탄으로 등장할 수 있도록 하자!" }, { "title": "JAXBContext, Unmarshaller와 lombok", "url": "/posts/jaxbcontext-unmarshaller-01/", "categories": "Java", "tags": "java, JAXBContext, Unmarshaller, lombok", "date": "2022-04-23 19:30:00 +0900", "snippet": " 해당 원글은 미디엄 블로그에서 작성한 내용을 해당 블로그에 기록하기 위해 가져옴.원글은 2021.01.22일 작성.개요 작업하다 보면 가끔씩 xml을 parsing해야 할 때가 종종 있다. json이면 참 편했을텐데 현실은 그렇지 않지… xml을 parsing하기 위해 어떤 libarary를 사용하면 좋을까~ 하고 검색해보면 꽤 다양한 library가 존재한다. gson-xml이라는 gson에서 만든 library도 있고, JDK 에서 제공하는 XPath, JAXBContext도 있고 다양한데 무엇을 선택하여 사용할지는 개발자의 마음이다. 여기선 어떤게 좋을까?라기보다 JAXBContext 사용하다가 발견한 사소한 정보를 공유하고자 한다. 우선 기본적인 JAXBContext 사용법은 검색하면 쭈르륵 나오니까 패스. 우리(?)가 좋아하는 lombok과 같이 한번 사용해보자.사용 예시xml정보를 담을 간단한 class@Getter@XmlRootElementpublic class User { @XmlElement private String name; @XmlElement private String character;}그리고 본격적으로 JABContext를 사용하여 xml을 parsing@Testpublic void unmarshallerTest() throws Exception { String response = \"&lt;?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?&gt;\\n\" + \"&lt;user&gt;\\n\" + \" &lt;name&gt;토끼겅쥬&lt;/name&gt;\\n\" + \" &lt;character&gt;전사&lt;/character&gt;\\n\" + \"&lt;/user&gt;\"; JAXBContext jaxbContext = JAXBContext._newInstance_(User.class); Unmarshaller unmars = jaxbContext.createUnmarshaller(); User user = (User) unmar.unmarshal(new StringReader(response)); System.out.println( \"name : \" + user.getName()); System.out.println( \"character : \" + user.getCharacter());}결과는 기대했던대로 잘 나온다.name : 토끼겅쥬character : 전사여기서 User class에 임의의 새로운 값이 필요하여 Getter를 Data annotation으로 바꾸고 다시 실행해보자.@Data@XmlRootElementpublic class User { @XmlElement private String name; @XmlElement private String character; private int level;}결과는 runtime Exception이 발생해버렸다.com.sun.xml.bind.v2.runtime.IllegalAnnotationsException: 2 counts of IllegalAnnotationExceptions클래스에 동일한 이름 \"character\"을(를) 사용하는 속성이 두 개 있습니다. this problem is related to the following location: at public java.lang.String com.naver.land.vapi.User.getCharacter() at com.naver.land.vapi.User this problem is related to the following location: at private java.lang.String com.naver.land.vapi.User.character at com.naver.land.vapi.User클래스에 동일한 이름 \"name\"을(를) 사용하는 속성이 두 개 있습니다. this problem is related to the following location: at public java.lang.String com.naver.land.vapi.User.getName() at com.naver.land.vapi.User this problem is related to the following location: at private java.lang.String com.naver.land.vapi.User.name at com.naver.land.vapi.User 이유가 뭘까나? JAXBContext, Annotation, Lombok 사용의 콜라보로 인한 오류인데 JAXBContext 동작 방식을 살펴보자 우선 @XmlElement annotation에 주목할 필요가 있다. unmarshal을 할때 해당 annotation이 지정 된 곳에 값이 세팅이 되는데 위의 예제엔 필드값에 지정이 되어 있기 때문에 필드값으로 바로 값이 세팅이 된다.그래서 setter를 사용하고 싶으면 setter 메소드에 annotation을 지정하면 된다. 이런식으로 setter에 @XmlElement를 추가@Getter@XmlRootElementpublic class User { private String name; private String character; @XmlElement public void setName(String name) { this.name = name; } @XmlElement public void setCharacter(String character) { this.character = character; }} 자 이쯤 되면 Data lombok annotaion을 사용했을 때 왜 아까와 같은 Exception이 발생했는지 파악했을 것이다. Data를 사용했다면 아래와 같이 풀어서 Getter,Setter가 각 필드에 지정되었을 것이다. XmlElement이 Setter에도 지정이 되어 필드,Setter 두곳에 동일한 이름의 속성이 생성되어 버린것이다.@XmlRootElementpublic class User { @Getter @Setter @XmlElement private String name; @Getter @Setter @XmlElement private String character;}마무리 그러므로 JABContext를 사용할 때 lombok을 같이 사용하고 싶다면 필드별로 Getter, Setter를 지정하는 것이 좋다. 넘 소박하고 사소한 정보였지만, 나 같이 오랜만에 xml parsing하려는 분이 있다면 도움이 되었길 바란다. ㅠ 참고로 검색하다가 봤는데 JABContext는 한번만 생성되는 게 좋다고 한다. 리소스가 생각보다 많이 소모 된다고 함. 반복문 안보다는 바깥에 놓도록 하자." }, { "title": "Java Checked Exception, Unchecked Exception", "url": "/posts/exception-01/", "categories": "Java, Exception", "tags": "java, exception, checked exception, unchecked exception", "date": "2022-04-22 22:50:00 +0900", "snippet": "개요Java에서 Error가 발생했을 때 처리하는 기본적인 개념을 한번 가볍게 정리하고자 한다.Error 코드를 작성할 때 Error는 예측할 수 있는 Error와 예측할 수 없는 Error로 나뉜다. 또한 복구할 수 없는 Error와 복구할 수 있는 Error로도 구분할 수 있다. Java에선 복구할 수 없는 Error는 Error Class를 상속받고, 복구할 수 있는 Error는 Exception을 상속받는다.Throwable 출처 https://devlog-wjdrbs96.tistory.com/351 모두 Throwable을 상속받으며, 호출한 상위 메서드로 처리를 위임할 수 있다.Checked Exception 예측할 수 있는 모든 예외. 꼭 처리를 해야하며 Spring에선 Controller에서 throw하면 결국 Error page(status 500)로 전달된다. Java Application에서는 Error page로 전달하는 경우가 없으니 더 신중하게 처리를 해야한다. Compile 단계에서 보통 확인이 가능하므로 예외에 맞춰서 try catch로 처리할지 아니면 throw할 것인지 정해진다. 실무에선 보통 Checked Exception은 문제가 되지 않는다.Unchecked Exception 다양한 예측이 어려운 예외. 물론 예측이 아예 안되는 것은 아니다. 대표적인 IndexOutOfBounds 혹은 NullPoint는 코드를 잘 살펴보면 예측이 가능하다. 하지만 바쁘게 코딩을 하다보면 놓치는 경우가 많다.. 예측 가능한 곳에서 Exception try catch로 잡아서 처리할 수 있고 Spring에선 적절한 error page나 error code로 응답한다.Spring Transaction Checked Exception일 경우엔 roll back 되지 않는다. roll back이 필요한 경우엔 Unchecked Exception을 throw 해서 처리되도록 한다. 또는 rollbackFor를 활용 관련해서 검색하면 내용이 많으니 넘어가도록 한다. 마무리 Exception은 언제봐도 머리아픈듯… Spring에서 Exception을 어떻게 처리할지에 대해 다음편을 통해서 확인해 볼 예정" }, { "title": "SpringBoot 프로젝트를 kubernetes 환경에 배포", "url": "/posts/SpringBoot-K8s-01/", "categories": "k8s, spring boot", "tags": "k8s, spring boot, minikube, deployment, nodeport", "date": "2022-04-15 00:10:00 +0900", "snippet": "개요SpringBoot 프로젝트를 kubernetes 환경에 배포하여 접속까지 확인하는 테스트를 진행한다.SpringBoot 프로젝트 생성간단하게 Spring Initializer를 통해서 생성한다.RestController 설정배포 후 확인을 위해 간단하게 설정.@RestController(\"/\")public class SampleRestController { @Value(\"${appName}\") private String appName; @GetMapping public String indexHome() { return appName + \" index\"; }}배포 환경 구성 kubernetes 환경을 로컬에서 테스트 하기 위해 minikube를 이용할 것이다. 또한 배포를 위해 docker hub에 image를 push 해야한다. minikube 및 docker 설치(pass 함)는 다른 Post에서 다루었다.빌드 및 배포SpringBoot 빌드$ ./gradlew bootJar혹은 Intellij를 이용한 Gradle 빌드jar 파일은 프로젝트홈/build/lib/ 디렉토리 밑에 생성된다.Docker Build &amp; Push Dockerfile 간단하게FROM adoptopenjdk/openjdk11ENV APP_HOME=/usr/app/WORKDIR $APP_HOMECOPY ./*.jar ./app.jarENTRYPOINT [\"java\", \"-jar\", \"app.jar\"] build 및 push build는 자신의 docker hub repository 밑으로 지정한다. Dockerfile이 존재하는 directory에서 아래 커맨드 수행 docker build -t {repositoryName}/{appName}:{tag} .docker push {repositoryName}/{appName}:{tag} 이제 kubernetes 환경에 배포할 준비가 다 되었다.minikube에 배포deployment와 nodeport yaml 파일을 생성. deploymentapiVersion: apps/v1kind: Deploymentmetadata: name: appName labels: app: appNamespec: replicas: 1 selector: matchLabels: app: appName template: metadata: labels: app: appName spec: containers: - name: appName image: docker.io/repositoryName/appName:tag ports: - containerPort: 8080 nodeport yamlapiVersion: v1kind: Servicemetadata: name: nodeport-servicespec: type: NodePort selector: app: appName ports: - protocol: TCP port: 80 targetPort: 8080 nodePort: 30000minikube 시작기본 설정으로 그냥 startminikube start설치 후 kubernetes 환경이 제대로 구성 되었는 지 확인kubectl get pods -Ayaml 설치kubectl apply -f deployment.yamlkubectl apply -f nodeport.yaml확인 docker hub에 제대로 image가 push 되었다면 문제없이 minikube kubernetes 환경에 배포가 되었을 것이다.pod가 Running 상태로 변경되었다면 port-forwarding을 통해 minikube kubernetes 서비스에 접속해보자.kubectl port-forward service/nodeport-service 9090:80 curl 혹은 브라우저를 통해 http://localhost:9090 으로 접속해보면 배포가 된 것을 확인할 수 있다.마무리 해당 프로젝트를 통해 ConfigMap을 활용하는 것 까지 다음 포스트에서 다루어 볼 예정." }, { "title": "IaaS, PaaS, SaaS", "url": "/posts/IaasPaasSaas-01/", "categories": "cloud", "tags": "cloud", "date": "2022-04-09 18:50:00 +0900", "snippet": "개요Cloud 서비스를 이해하기 위해 IaaS, PaaS, SaaS 개념에 대해 이해해 보자.Cloud 서비스 모델 출처 : https://www.whatap.io/ko/blog/9/IaaS Infrastructure as a service설명 물리적 컴퓨팅 리소스, 위치, 데이터 분할, 확장, 보안, 백업 등과 같은 기본 네트워크 인프라의 다양한 하위 수준 세부 정보를 역참조하는 데 사용되는 상위 수준 API를 제공하는 온라인 서비스입니다. Xen, Oracle VirtualBox, Oracle VM, KVM, VMware ESX/ESXi 또는 Hyper-V는 가상 머신을 게스트로 실행합니다. 클라우드 운영 체제 내의 하이퍼바이저 풀은 많은 수의 가상 머신과 고객의 다양한 요구 사항에 따라 서비스를 확장 및 축소할 수 있는 기능을 지원할 수 있습니다.PaaS Platform as a Service설명 PaaS(Platform as a Service) 또는 aPaaS(Application Platform as a Service) 또는 플랫폼 기반 서비스는 고객이 컴퓨팅 플랫폼과 하나 또는 일반적으로 애플리케이션 개발 및 실행과 관련된 인프라 구축 및 유지 관리의 복잡성 없이 더 많은 애플리케이션, 개발자가 그러한 소프트웨어 번들을 생성, 개발 및 패키징할 수 있도록 합니다.SaaS Software as a service설명 서비스로서의 소프트웨어(SaaS)는 소프트웨어 라이선스 및 제공 모델로, 구독 기반으로 라이선스가 부여되고 중앙에서 호스팅됩니다. SaaS는 “주문형 소프트웨어” 및 웹 기반/웹 호스팅 소프트웨어로도 알려져 있습니다.SaaS는 IaaS(Infrastructure as a Service), PaaS(Platform as a Service), DaaS(Desktop as a Service), MSaaS(Managed Software as a Service), 모바일 백엔드와 함께 클라우드 컴퓨팅의 일부로 간주됩니다. 서비스로서의 데이터 센터(MBaaS), 서비스로서의 데이터 센터(DCaaS), 서비스로서의 통합 플랫폼(iPaaS) 및 서비스로서의 정보 기술 관리(ITMaaS).SaaS 앱은 일반적으로 씬 클라이언트를 사용하여 사용자가 액세스합니다. 웹 브라우저를 통해. SaaS는 사무용 소프트웨어, 메시징 소프트웨어, 급여 처리 소프트웨어, DBMS 소프트웨어, 관리 소프트웨어, CAD 소프트웨어, 개발 소프트웨어, 게임화, 가상화, 회계, 협업, 고객 관계 관리(CRM)를 포함한 많은 비즈니스 애플리케이션의 공통 제공 모델이 되었습니다.마무리 개념 자체는 어렵지 않은 것 같은데 실제 플랫폼을 제공하려 할때 뭔가 구분이 모호한 경우도 생기는 것 같다." }, { "title": "PodSecurityPolicy unable to admit pod", "url": "/posts/PodSecurityPolicy-01/", "categories": "k8s, kubeflow, pipeline", "tags": "k8s, kubeflow, pipeline, pod, PodSecurityPolicy", "date": "2022-04-07 22:50:00 +0900", "snippet": "개요k8s에 kubeflow를 설치 한 뒤 pipeline을 Run 하려고 할때 PodSecurityPolicy: unable to admit pod 오류 발생.오류 내용메세지 예시This step is in Error state with this message: task 'xx' errored: pods \"kube-pipeline\" is forbidden: PodSecurityPolicy: unable to admit pod: []발생 환경 cluster plugin PodSecurityPolicy가 enable상태일 경우. kubeflow 1.5 환경에서 발생.원인 참고 : https://kubernetes.io/docs/concepts/security/pod-security-policy/ 대략적인 요약 Pod를 생성할 때 일반적으로 컨트롤러 관리자를 통해 생성. 정책에 대한 컨트롤러 액세스 권한이 필요한데 해당 정책이 없으면 Pod생성이 되지 않음. PodSecurityPolicy일단 k8s 1.25에서 삭제될 예정이다. Caution: PodSecurityPolicy is deprecated as of Kubernetes v1.21, and will be removed in v1.25.해결 방법 kubeflow는 rbac을 사용. 아래와 같이 ClusterRole의 rules에 정책 추가apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRolemetadata: name: &lt;role name&gt;rules:- apiGroups: ['policy'] resources: ['podsecuritypolicies'] verbs: ['use'] resourceNames: - &lt;list of policies to authorize&gt;kubeflow ClusterRole 대상 kubeflow-kubernetes-admin kubeflow-kubernetes-edit kubeflow-kubernetes-view대상 ClusterRole 모두 수정 후 pipeline을 run해보자.마치며 실제 테스트는 생략한다. kubeflow에서 사용하는 ClusterRole이 많아 PSP를 사용하는 Cluster의 경우엔 여러가지 확인이 필요하다." }, { "title": "Mac OS Minikube 설치", "url": "/posts/minikube-01/", "categories": "k8s", "tags": "k8s, local k8s, minikube", "date": "2022-04-04 23:00:00 +0900", "snippet": "개요k8s, container 환경을 공부하기 위해 local 환경에서 k8s 테스트 하기 위해 minikube를 설치.설치 환경 운영체제 : MacOS Catalina 프로세서 : 3 GHz 듀얼 코어 Intel Core i7 메모리 : 8GB설치 설치 가이드 링크 : https://minikube.sigs.k8s.io/docs/start/필요 사양 2 CPUs or more 2GB of free memory 20GB of free disk space Internet connection Container or virtual machine manager, such as: Docker, Hyperkit, Hyper-V, KVM, Parallels, Podman, VirtualBox, or VMware Fusion/Workstation 필요한 하드웨어 사양은 갖춘거 같다… 그리고 Docker(그 외..)가 필요하다고 나와 있으니 Dcoker를 우선 설치하자.Docker 설치 설치 링크 : https://www.docker.com/get-started Docker 설치는 Pass다시 minikube 설치Mac은 Homebrew로 보통 설치brew install minikube설치는 이걸로 끝이다.자세한 가이드는 minikube 사이트에서 확인하자.시작minikube startminikube 시작도 간단하다.그 밖에 여러가지 옵션이 제공되니 필요한 경우에 활용하도록 하자. 아무런 옵션이 없다면 최신버전의 k8s가 설치됨.설치 후 확인kubectl get pods -A삭제설치는 아래 순서대로 하면 간단하게 삭제 완료.minikube stopminikube delete --all마치며 설치하면서도 시간이 참 오래걸리는 거 같다. 이번 포스팅은 여기까지만 하고 앞으로 k8s를 활용한 여러 컨테이너 테스트를 할 예정이다." }, { "title": "객체는 인터페이스를 사용해 참조하라", "url": "/posts/interface-01/", "categories": "Java, Coding", "tags": "coding, effective java", "date": "2022-03-31 23:00:00 +0900", "snippet": "개요이펙티브 자바에서 나온 내용인데 자주 활용하지만, 면접때 왜? 라고 하면 떠오르지 않을 수 있기 때문에 회고.가장 많이 쓰는 예시List&lt;Object&gt; lists = new ArryaList&lt;&gt;();List는 거의 ArrayList로 생성해서 사용한다. 그렇다고 유연하게 쓰진 않지만…그래서 왜?책에서 강조한 내용은 아래와 같다 인터페이스를 타입으로 사용하는 습관을 길러두면 프로그램이 훨씬 유연해질 것이다.유연해진다는 것이 무엇인지 좀 더 알아보자.간단 예시public void calculateData(Map&lt;Boole, Object&gt; data) { // TODO : calculation}이와 같이 Map을 주입 받으면 Map을 구현한 구현체를 모두 사용할 수 있는 메서드가 된다.특별히 사용하고자 하는 구현체를 주입해도 해당 메서드는 문제 없이 동작 할 수 있다는 것이다.아래와 같이 사용 가능하다.Map&lt;Boole, Object&gt; datas = new EnumMap&lt;Boole, Object&gt;(Boole.class);Map&lt;Boole, Object&gt; linkedDatas = new LinkedHashMap&lt;&gt;();calculateData(datas);calculateData(linkedDatas); 임의의 인터페이스를 만들고 그것을 구현한 구현체를 여러가지 종류 만들게 되면, 인터페이스로 선언하여 유연하게 다양한 동작을 처리할 수 있다.그래도…항상 인터페이스만 사용하라는 것은 아니다.확장성이 필요할 때 문제이고, 적합한 인터페이스가 없다면 당연히 클래스로 참조해야 한다.인터페이스 구현 메소드외 특별한 메소드를 포함한 클래스는 인터페이스로 선언할 수 없다.하지만 이러한 경우는 최소화 해야 한다.결론간단한 구조라도 인터페이스를 사용하는 것에 익숙해지는 게 좋을 것이다." }, { "title": "블로그 시작", "url": "/posts/blog-start/", "categories": "Blogging", "tags": "blogging, start", "date": "2022-03-28 23:00:00 +0900", "snippet": "시작하며그 동안 블로그를 전전하면서 맘에 드는 곳을 찾아다니다가 드디어 정착할 만한 곳을 찾았다.바로 Github Blog이다. markdown 문법으로 작성하는게 귀찮긴 하지만, 뭔가 개발자 감성에 맞는달까?평소 업무할때도 markdown 문법을 자주 사용하므로 큰 문제는 없을 것 같다.블로그 시작할 때마다 매번 엎어지지만 이번에야말로! 다시 한번 도전해보자.Markdown 예제필요한 문법 몇개 한번 확인 겸 끄적거리고 마무리 해보자.가장 중요한 코드 블럭public class HelloWorld { public static void main(String[ ] args) { System.out.println(\"Hello World!\"); }}중요 문구 여기에 중요 포인트? 작성" } ]
